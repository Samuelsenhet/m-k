# Supabase Development Guidelines for m-k

## Project Overview
This project uses Supabase as the backend infrastructure with Next.js v16 for the frontend. Follow these guidelines to ensure consistency, security, and optimal performance.

---

## 1. Supabase Realtime Best Practices

### Connection Management
- **Always clean up subscriptions**: Use `useEffect` cleanup functions or component unmount handlers to unsubscribe from channels
- **Avoid multiple subscriptions**: Reuse existing channels when possible, consolidate listeners
- **Use presence judiciously**: Only track presence when necessary; it adds overhead

```javascript
// ✅ Good: Proper cleanup
useEffect(() => {
  const channel = supabase
    .channel('room-1')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'messages' }, payload => {
      handleRealtimeUpdate(payload)
    })
    .subscribe()

  return () => {
    supabase.removeChannel(channel)
  }
}, [])

// ❌ Bad: No cleanup
useEffect(() => {
  supabase
    .channel('room-1')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'messages' }, payload => {
      handleRealtimeUpdate(payload)
    })
    .subscribe()
}, [])
```

### Channel Naming
- Use descriptive, hierarchical channel names: `resource:id:sub-resource`
- Examples: `chat:room-123:messages`, `project:456:updates`
- Avoid generic names like `channel1`, `updates`

### Filtering and Security
- **Enable RLS**: Always enable Row Level Security on tables with Realtime
- **Filter on the client**: Use Realtime filters to reduce bandwidth
- **Validate permissions**: Ensure users only subscribe to data they can access

```javascript
// ✅ Good: Filtered subscription
const channel = supabase
  .channel('projects')
  .on('postgres_changes', {
    event: 'INSERT',
    schema: 'public',
    table: 'projects',
    filter: `user_id=eq.${userId}`
  }, handleNewProject)
  .subscribe()
```

### Performance Considerations
- **Throttle updates**: Use debouncing/throttling for high-frequency updates
- **Batch operations**: Group related database operations
- **Monitor connection count**: Realtime has connection limits per plan
- **Use broadcast for ephemeral data**: Presence/broadcast don't hit the database

---

## 2. Next.js v16 Auth SSR Patterns

### Server Components (Default)
- **Use Server Components by default** for authenticated pages
- **Access session server-side** using `createServerComponentClient`
- **Redirect unauthenticated users** before rendering

```typescript
// app/dashboard/page.tsx
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { redirect } from 'next/navigation'

export default async function DashboardPage() {
  const supabase = createServerComponentClient({ cookies })
  
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session) {
    redirect('/login')
  }

  // Fetch data server-side
  const { data: projects } = await supabase
    .from('projects')
    .select('*')
    .eq('user_id', session.user.id)

  return <DashboardView projects={projects} />
}
```

### Client Components
- **Mark with 'use client'** when you need interactivity or Realtime
- **Use `createClientComponentClient`** for client-side operations
- **Handle loading states** during session checks

```typescript
// components/RealtimeMessages.tsx
'use client'

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { useEffect, useState } from 'react'

export default function RealtimeMessages({ initialMessages }) {
  const supabase = createClientComponentClient()
  const [messages, setMessages] = useState(initialMessages)

  useEffect(() => {
    const channel = supabase
      .channel('messages')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'messages'
      }, payload => {
        setMessages(prev => [...prev, payload.new])
      })
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [supabase])

  return <MessageList messages={messages} />
}
```

### Middleware for Auth
- **Protect routes** using middleware
- **Refresh session** automatically
- **Handle redirects** before page load

```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  const { data: { session } } = await supabase.auth.getSession()

  // Protect dashboard routes
  if (req.nextUrl.pathname.startsWith('/dashboard') && !session) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  // Redirect authenticated users away from auth pages
  if (req.nextUrl.pathname.startsWith('/login') && session) {
    return NextResponse.redirect(new URL('/dashboard', req.url))
  }

  return res
}

export const config = {
  matcher: ['/dashboard/:path*', '/login', '/signup']
}
```

### Route Handlers (API Routes)
- **Use Route Handlers** for API endpoints
- **Create supabase client** with cookies
- **Return proper HTTP status codes**

```typescript
// app/api/projects/route.ts
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const supabase = createRouteHandlerClient({ cookies })
  
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { data, error } = await supabase
    .from('projects')
    .select('*')
    .eq('user_id', session.user.id)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ data })
}
```

### Environment Variables
```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key # Server-side only!
```

---

## 3. Edge Functions Guidelines

### Function Structure
- **Keep functions focused**: One function, one responsibility
- **Use TypeScript**: Type safety prevents runtime errors
- **Handle CORS**: Configure CORS headers for browser requests

```typescript
// supabase/functions/process-payment/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Create authenticated client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    // Verify user
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser()
    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      })
    }

    // Process request
    const { amount } = await req.json()
    
    // Business logic here
    const result = await processPayment(amount, user.id)

    return new Response(JSON.stringify({ success: true, result }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 400,
    })
  }
})
```

### Security Best Practices
- **Validate all inputs**: Never trust client data
- **Use service role key carefully**: Only when necessary, never expose to client
- **Implement rate limiting**: Protect against abuse
- **Log security events**: Track suspicious activity

### Error Handling
- **Return meaningful errors**: Help debug issues
- **Use proper status codes**: 400 for client errors, 500 for server errors
- **Log errors**: Use console.error for debugging

### Testing
- **Test locally**: Use Supabase CLI `supabase functions serve`
- **Write unit tests**: Test business logic separately
- **Test authentication**: Verify auth flows work correctly

### Calling Edge Functions from Next.js
```typescript
// Client-side
const { data, error } = await supabase.functions.invoke('process-payment', {
  body: { amount: 1000 },
})

// Server-side (with service role)
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

const { data, error } = await supabaseAdmin.functions.invoke('admin-task', {
  body: { userId: 'user-123' },
})
```

---

## 4. Database Schema Management Rules

### Migration Workflow
- **Never edit migrations**: Create new ones for changes
- **Use descriptive names**: `20240108_add_user_profiles_table.sql`
- **Test migrations locally**: Before applying to production
- **Version control all migrations**: Commit to git

```sql
-- Example migration: supabase/migrations/20240108_add_projects_table.sql

-- Create projects table
create table public.projects (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  name text not null,
  description text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.projects enable row level security;

-- RLS Policies
create policy "Users can view their own projects"
  on public.projects for select
  using (auth.uid() = user_id);

create policy "Users can insert their own projects"
  on public.projects for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own projects"
  on public.projects for update
  using (auth.uid() = user_id);

create policy "Users can delete their own projects"
  on public.projects for delete
  using (auth.uid() = user_id);

-- Indexes
create index projects_user_id_idx on public.projects(user_id);
create index projects_created_at_idx on public.projects(created_at desc);

-- Enable Realtime (optional)
alter publication supabase_realtime add table public.projects;
```

### Schema Design Principles
- **Use UUIDs for primary keys**: Better for distributed systems
- **Always include timestamps**: `created_at`, `updated_at`
- **Foreign keys with ON DELETE**: Specify cascade or set null behavior
- **Normalize appropriately**: Balance between normalization and query performance
- **Use enums for fixed values**: Create custom types for status fields

```sql
-- Custom enum type
create type public.project_status as enum ('draft', 'active', 'archived');

alter table public.projects add column status public.project_status default 'draft';
```

### Row Level Security (RLS)
- **Always enable RLS**: For all user-facing tables
- **Write specific policies**: One policy per operation (select, insert, update, delete)
- **Test policies thoroughly**: Verify users can't access unauthorized data
- **Use functions in policies**: For complex logic

```sql
-- Policy with function
create or replace function public.is_project_member(project_id uuid)
returns boolean as $$
  select exists (
    select 1
    from public.project_members
    where project_id = $1
    and user_id = auth.uid()
  );
$$ language sql security definer;

create policy "Project members can view projects"
  on public.projects for select
  using (is_project_member(id));
```

### Indexes and Performance
- **Index foreign keys**: Always index columns used in joins
- **Index filtered columns**: Columns used in WHERE clauses
- **Composite indexes**: For multi-column filters
- **Monitor query performance**: Use `EXPLAIN ANALYZE`

```sql
-- Composite index for common query
create index projects_user_status_idx on public.projects(user_id, status);

-- Partial index for active projects only
create index active_projects_idx on public.projects(user_id) 
  where status = 'active';
```

### Functions and Triggers
- **Use triggers for automatic updates**: Like updating `updated_at`
- **Write SECURITY DEFINER functions carefully**: They bypass RLS
- **Return proper types**: Specify return types explicitly

```sql
-- Trigger function for updated_at
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Apply to table
create trigger set_updated_at
  before update on public.projects
  for each row
  execute function public.handle_updated_at();
```

### Backup and Recovery
- **Regular backups**: Supabase handles this, but export critical data
- **Test restore procedures**: Verify backups work
- **Document rollback steps**: For each major migration

---

## 5. General Best Practices

### Type Safety
- **Generate TypeScript types**: Use `supabase gen types typescript`
- **Update types regularly**: After schema changes
- **Use typed clients**: Import Database types

```typescript
// types/supabase.ts (generated)
import { Database } from '@/types/supabase'

const supabase = createClientComponentClient<Database>()

// Fully typed query
const { data } = await supabase
  .from('projects')
  .select('*')
  .eq('status', 'active') // TypeScript knows valid statuses
```

### Error Handling
- **Always check for errors**: Supabase returns `{ data, error }`
- **Provide user-friendly messages**: Don't expose technical details
- **Log errors for debugging**: Use error tracking service

```typescript
const { data, error } = await supabase
  .from('projects')
  .select('*')

if (error) {
  console.error('Database error:', error)
  throw new Error('Failed to load projects. Please try again.')
}
```

### Environment Management
- **Separate environments**: Development, staging, production
- **Never commit secrets**: Use `.env.local`, add to `.gitignore`
- **Use Supabase CLI**: For local development with `supabase start`

### Documentation
- **Document complex queries**: Add comments to explain logic
- **Maintain README**: Keep setup instructions updated
- **Document API contracts**: For Edge Functions and Route Handlers

---

## Quick Reference Commands

```bash
# Local development
supabase start                    # Start local Supabase
supabase db reset                 # Reset local database
supabase db push                  # Push migrations to remote
supabase gen types typescript     # Generate TypeScript types

# Edge Functions
supabase functions new my-function      # Create new function
supabase functions serve my-function    # Test locally
supabase functions deploy my-function   # Deploy to remote

# Migrations
supabase migration new create_something # Create new migration
supabase db diff                        # See schema changes
```

---

## Resources
- [Supabase Documentation](https://supabase.com/docs)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Supabase Auth Helpers](https://supabase.com/docs/guides/auth/auth-helpers/nextjs)
- [Edge Functions Guide](https://supabase.com/docs/guides/functions)

---

**Last Updated**: 2026-01-08
**Maintainer**: Development Team